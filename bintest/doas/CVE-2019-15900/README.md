the principle of the vulnerability is that when parsing uids and gids with
sscanf, the return value of sscanf is not checked so if the string is not a
number, the return value `gid` is uninitialized memory.

```
static int
parsegid(const char *s, gid_t *gid)
{
	struct group *gr;
	const char *errstr;

	if ((gr = getgrnam(s)) != NULL) {
                // this never happens in our stub
		*gid = gr->gr_gid;
		return 0;
	}
        #ifndef linux
	*gid = strtonum(s, 0, GID_MAX, &errstr);
        #endif
        #ifdef linux
        sscanf(s, "%d", gid);
        #endif
	if (errstr)
		return -1;  // this branch is optimized out by gcc
	return 0;
}
```

The goal is to find an example of configuration of doas where the attacker can
reliably use doas to become root.

The assumptions are as follows:
* the configuration has 2 rules with no target, command, and environment.
* identifiers are printable ascii, max 8 chars
* uids and gids are 1 base-10 digit (for the stub of sscanf)
* getgrnam and getpwnam always fail (no named user on the system or more
* likely, there are typos in the configuration file)


The crux of the exploit is that the same gid is reused for calling parsegid for
each rule.  So if the first time `sscanf` parses successfully the gid of the
attacker (and then denies for some other reason) and the second time, parsing
fails, then it will as if the attacker's gid was parsed again.

In the mem file, the attacker's gid is 7.

doas root accepts with these rules:
```
deny :7
permit nopass :typo
```

Reliable exploitation with one rule is impossible (well, with our entrypoint),
and non robust SE will return a model where it assumes proper initialisation of 
uninitialized memory.

variants are as follows: 1 and 2 indicate with 1 or 2 rules, and robust vs
normal the SE flavor.

A non tested variant `typo` is provided where the username is hardcoded to a reasonable typo (`wwww`)
to illustrate that the username is actually not read, and any (non-existing) username works.

